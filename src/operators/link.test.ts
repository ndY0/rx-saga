import { from } from "rxjs";
import { busMock, execMock } from "../mocks/bus.mock";
import SagaSubject from "../observable/saga-observable";
import ErrorMock from "../mocks/error.mock";
import link from "./link";

describe('link', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    })
    afterAll(() => {
        jest.resetAllMocks();
    })  
    it(`should allow to map the previous response to a new command`, (done) => {
        const response = { type: 'response' };
        const response2 = { type: 'response2' };
        execMock.mockImplementationOnce(() => {
            return from([response]);
        });
        execMock.mockImplementationOnce(() => {
            return from([response2]);
        });

        const mapErrorUpstreamSpy = jest.fn<{ type: 'errorCommand' }, [ErrorMock]>((error: ErrorMock) =>({ type: 'errorCommand' }));
        const mapErrorResponseUpstreamSpy = jest.fn<{ type: 'errorResponse' }, [any]>((errorResponse: any) =>({ type: 'errorResponse' }));
        const mapResponseUpstreamSpy = jest.fn<{ type: 'response' }, [any]>((response: any) =>(response));
        const saga = new SagaSubject<{ type: 'command' }, { type: 'response' }, ErrorMock, { type: 'errorCommand' }, { type: 'errorResponse' }>(busMock(), mapErrorUpstreamSpy, mapResponseUpstreamSpy, mapErrorResponseUpstreamSpy);
        const command: { type: 'command' } = { type: 'command' };
        const command2: { type: 'command2' } = { type: 'command2' };
        const mapSpy = jest.fn<{ type: 'command2' }, [{ type: 'response' }]>((upstream: { type: 'response' }) => (command2));
        const liftErrorSpy = jest.fn<{ type: 'errorCommand' }, [{ type: 'errorResponse2' }]>((errorResponse: { type: 'errorResponse2' }) =>({ type: 'errorCommand' }));
        const mapErrorSpy = jest.fn<{ type: 'errorCommand2' }, [ErrorMock]>((error: ErrorMock) =>({ type: 'errorCommand2' }));
        const mapErrorResponseSpy = jest.fn<{ type: 'errorResponse2' }, [any]>((errorResponse: any) =>({ type: 'errorResponse2' }));
        const mapResponseSpy = jest.fn<{ type: 'response2' }, [any]>((response: any) =>({ type: 'response2' }));
        let count = 0;
        const downstream = saga.pipe(link(mapSpy, liftErrorSpy, mapErrorSpy, mapResponseSpy, mapErrorResponseSpy));
        downstream.toObservable().subscribe({
            next(value) {
                count += 1;
                expect(execMock).toHaveBeenCalledTimes(2 * count);
                expect(execMock).toHaveBeenNthCalledWith(2 * (count - 1) + 1, command);
                expect(execMock).toHaveBeenNthCalledWith(2 * (count), command2);
                expect(mapSpy).toBeCalledTimes(count);
                expect(mapSpy).toHaveBeenNthCalledWith(count, response);
                expect(value.type).toBeDefined();
                expect(value.type).toEqual('response2');
            },
            complete() {
                expect(count).toEqual(1);
                done();
            },
        });
        saga.next(command);
        saga.next(command);
        saga.complete();
    });
    it(`should allow to link the error response generated by this new error response to the previous error command`, (done) => {
        const response = { type: 'response' };
        const response2 = { type: 'response2' };
        execMock.mockImplementationOnce(() => {
            return from([response]);
        });
        execMock.mockImplementationOnce(() => {
            return from([response2]);
        });

        const mapErrorUpstreamSpy = jest.fn<{ type: 'errorCommand' }, [ErrorMock]>((error: ErrorMock) =>({ type: 'errorCommand' }));
        const mapErrorResponseUpstreamSpy = jest.fn<{ type: 'errorResponse' }, [any]>((errorResponse: any) =>({ type: 'errorResponse' }));
        const mapResponseUpstreamSpy = jest.fn<{ type: 'response' }, [any]>((response: any) =>(response));
        const saga = new SagaSubject<{ type: 'command' }, { type: 'response' }, ErrorMock, { type: 'errorCommand' }, { type: 'errorResponse' }>(busMock(), mapErrorUpstreamSpy, mapResponseUpstreamSpy, mapErrorResponseUpstreamSpy);
        const command: { type: 'command' } = { type: 'command' };
        const command2: { type: 'command2' } = { type: 'command2' };
        const mapSpy = jest.fn<{ type: 'command2' }, [{ type: 'response' }]>((upstream: { type: 'response' }) => (command2));
        const liftErrorSpy = jest.fn<{ type: 'errorCommand' }, [{ type: 'errorResponse2' }]>((errorResponse: { type: 'errorResponse2' }) =>({ type: 'errorCommand' }));
        const mapErrorSpy = jest.fn<{ type: 'errorCommand2' }, [ErrorMock]>((error: ErrorMock) =>({ type: 'errorCommand2' }));
        const mapErrorResponseSpy = jest.fn<{ type: 'errorResponse2' }, [any]>((errorResponse: any) =>({ type: 'errorResponse2' }));
        const mapResponseSpy = jest.fn<{ type: 'response2' }, [any]>((response: any) =>({ type: 'response2' }));
        let count = 0;
        const downstream = saga.pipe(link(mapSpy, liftErrorSpy, mapErrorSpy, mapResponseSpy, mapErrorResponseSpy));
        downstream.toObservable().subscribe({
            next(value) {
                count += 1;
                expect(execMock).toHaveBeenCalledTimes(2 * count);
                expect(execMock).toHaveBeenNthCalledWith(2 * (count - 1) + 1, command);
                expect(execMock).toHaveBeenNthCalledWith(2 * (count), command2);
                expect(mapSpy).toBeCalledTimes(count);
                expect(mapSpy).toHaveBeenNthCalledWith(count, response);
                expect(value.type).toBeDefined();
                expect(value.type).toEqual('response2');
            },
            complete() {
                expect(count).toEqual(1);
                done();
            },
        });
        saga.next(command);
        saga.next(command);
        saga.complete();
    });
});